# 3장 설계 원칙

많은 설계 원칙들을 이해하는 것도 중요하지만 어떻게 사용하는지 정확히 알고 있는 게 중요함

# 3.1 단일 책임 원칙

Single Responsibility Principle, SOLID 원칙 중 하나

**클래스**와 **모듈**은 하나의 책임 또는 기능만 가지고 있어야 함

모듈을 클래스의 **추상적 개념**으로 볼 수도, **포괄적 개념**으로 볼 수도 있음

어떻게 이해하든 적용할 때에 맥락을 잘 따르면 충분히 쉽게 적용할 수 있음

**클래스에 단일 책임이 있는지 판단하는 방법**

- 특정 클래스에 대해 멤버 변수들을 보고 판단할 수 있음
- 이때 분리해야 하는 기준은 현재 독립적으로 관리해야 할 필요가 있는지로 판단
- 서비스의 비즈니스 수준에 따라 책임의 기준이 달라지기 때문

**클래스 분할을 고려해야 하는 경우**

- 코드가 점점 많아지는 경우
- 클래스의 의존성이 높아지는 경우
- 클래스에 private 메서드가 많아지는 경우
    - public 메서드로 설정해 코드의 재사용성 향상
- 클래스의 이름을 지정하기 어렵거나, 일반적인 단어로만 정의하기 좋은 경우
    - 책임의 정의가 명확하지 않다는 뜻
- 특정 메서드들이 특정 속성에서만 작동하는 경우

무조건 세분화하는 것이 좋은 것은 아님

중복되는 코드가 생기기 때문 → 코드 응집력 저하, 유지 보수성 저하

# 3.2 개방 폐쇄 원칙

Open-closed Principle, 확장할 때는 개방, 수정할 때는 폐쇄

적용하기 어려운 이유는 코드 변경이 확장인지 수정인지 명확하지 않기 때문

**코드 품질을 판단**하는 중요한 척도이므로 잘 고려해야 하는 원칙 중 하나

새로운 기능을 추가할 때는 기존 코드를 기반으로 모듈, 클래스, 함수를 추가하는 방식으로 확장해야 함

코드 수정은 OCP를 위반하는 것인가?

- 단위 테스트를 깨뜨리지 않는다면, 원칙을 위반하지 않는다고 봐도 무방함

⇒ 수정을 지양하는 게 아닌, 수정 가능한 수준에서 진행하고, 추가적인 작업을 확장으로 진행

처음부터 확장을 잘 고려해서 작성해야 함

- 확장, 추상화, 캡슐화에 대해 사전에 이해하고 있어야 함
- 하지만 비즈니스와 시스템에 맞춰서 적당한 설계를 진행해야 함

# 3.3 리스코프 치환 원칙

Liskov Substitution Principle, 하위 유형의 클래스가 상위 클래스를 대체할 수 있음

**계약에 따른 설계**

일반적으로 위반할 일이 잘 없음

다형성과 비슷해 보이지만, 다형성으로 코드를 구현한다고 해서 상위 클래스를 대체할 수 없는 경우가 존재함

### 위반하는 대표 사례

- 하위 클래스가 상위 클래스의 함수를 재정의하는 경우
- 하위 클래스가 상위 클래스의 입출력 예외에 대한 내용을 변경하는 것
- 하위 클래스가 상위 클래스의 주석 지침을 위반하는 경우

단위 테스트를 통해 리스코프 치환 원칙을 지켰는지 확인할 수도 있음

# 3.4 인터페이스 분리 원칙

Interface Segregation Principle, 클라이언트는 필요하지 않은 인터페이스를 사용하도록 강요되면 안됨

API 기능의 집합을 클라이언트에게 제공할 때는, 필요한 부분만 분리하여 제공해야 함

단일 API의 경우, 단일 책임 원칙과 유사하게 하나의 기능만 제공해야 함

# 3.5 의존 역전 원칙

Dependency Inversion Principle, 상위 모듈은 하위 모듈에 의존하지 않아야 하며, 추상화에 의존해야 함

### 제어 반전

이전에는 프로그래머가 프로그램의 실행 흐름을 제어했음

프레임워크를 사용하면 흐름의 제어가 프로그래머에서 프레임워크로 역전됨

### 의존성 주입

외부에서 종속 클래스의 객체를 생성하고, 생성자, 매개변수 등으로 필요한 클래스에 주입하는 것

# 3.6 KISS 원칙과 YAGNI 원칙

### KISS 원칙

Keep It Simple & Stupid, Short & Simple, Simple & Straight forward

가능한 한 단순하게 유지해야 하지만, 여러 해석이 존재하는 포괄적인 원칙

줄 수가 적다고 간단한 것은 아님, 복잡하다고 원칙을 위반하지 않음

원칙을 만족하는 방법

- 너무 높은 레벨의 기술을 사용하지 않아야 함
- 기존 라이브러리를 사용하는 것을 고려함
- 너무 과하게 최적화하지 않음

### YAGNI

You Ain’t Gonna Need It

현재 사용하지 않는 것을 설계하고 작성하지 말라는 원칙

여러 프로젝트에서 자주 사용하는 파일들을 한번에 도입하는 것이 대표적인 위반 사례

# 3.7 DRY 원칙

Don’t Repeat Yourself

중복 코드를 작성하지 말라는 원칙

코드의 논리가 중복돼도 의미적으로 다르면 다르다고 할 수 있음

가장 중요한 척도는 **코드 재사용성**

# 3.8 LoD

데메테르의 법칙 (Law Of Demeter)

높은 응집도와 낮은 결합도를 달성하는 데 도움이 되는 법칙

**높은 응집도** → 클래스 자체의 설계에 사용되는 지표

**낮은 결합도** → 클래스 간의 의존성 설계에 사용되는 지표

두 지표는 독립적이지 않기 때문에 잘 선택해야 함

**최소 지식의 원칙**이라고도 부름

모든 유닛이 자신과 밀접하게 관련된 유닛에 대해 제한된 지식만 알아야 한다는 원칙