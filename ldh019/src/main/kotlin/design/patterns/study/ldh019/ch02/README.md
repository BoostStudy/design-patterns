# 2장 객체지향 프로그래밍 패러다임

# 2.1 객체지향이란 무엇인가?

- 객체지향 프로그래밍
    
    : 프로그래밍 패러다임 또는 프로그래밍 스타일
    
    : 코드를 구성하는 기본 단위는 클래스 또는 객체
    
    : 코드 설계와 구현으로 캡슐화, 추상화, 상속, 다형성을 사용
    
- 객체지향 프로그래밍 언어
    
    : 클래스 또는 객체 문법을 지원
    
    : 캡슐화, 추상화, 상속, 다형성을 쉽게 구현할 수 있음
    
- 4가지 특성을 모두 갖출 필요는 없지만, 이런 특성들을 사용하는 게 객체지향 코드 설계 구현에 용이함
- is-a 클래스 관계를 잘 따를 수 있는 방법 뿐만 아니라 코드 재사용 문제도 해결 가능

### 객체지향 소프트웨어 개발 3단계

객체지향 분석 - 객체지향 설계 - 객체지향 프로그래밍

분석과 설계 단계에서도 객체지향 개념을 고려하여 진행해야함

- 프로그래밍으로 전환하기 쉬움

### UML?

설계를 잘 표현하는 데에 도움되는 도구일 수 있지만 학습에 시간이 많이 소요됨

완벽하게 사용하는 데에 있어 얻는 이익이 크지 않는 경우가 많음

단순하게 필요한만큼만 사용하는 것으로 충분함

## 생각해보기

1. UML에 사용되는 다이어그램의 종류가 너무 많고, 각 다이어그램에 사용하는 기호들이 다르기 때문에 처음 학습하기에 익숙해져야 하는 부분들이 너무 많다. 한 예로, 클래스 간의 관계에 대해 다양한 종류를 정의하는데, 수많은 종류가 객체지향에서 모두 사용이 되지 않고, 모든 종류에 대해 구현하기도 어렵고 애매하다고 생각한다.
2. 디자인 패턴 역시 재사용성, 코드 가독성, 유지 보수 용이성 등에 대한 고민 끝에 나온 것이라고 생각이 들고, 이와 같은 맥락의 개념인 객체지향의 기조와 잘 맞고 많은 것들을 공유하고 있다고 생각한다.

# 2.2 캡슐화, 추상화, 상속, 다형성이 등장한 이유

## 캡슐화(정보 은닉, 데이터 엑세스 보호)

- 접근 가능한 인터페이스를 제한함
- 클래스가 제공하는 메서드로만 접근을 허가하는 것
    - Java의 경우, private / public 같은 키워드를 이용하여 내부 변수에 대한 접근을 제한
- 속성에 대한 접근을 제한하지 않으면 유연해 보이지만 제어할 수 없다는 뜻이기도 함
    
    → 코드 가독성, 유지 관리 용이성에 영향을 줌
    
- 세부적인 비즈니스 로직에 대한 이해 없이 사용이 가능

## 추상화

- 메서드의 내부 구현을 숨기는 것
    - Java의 경우, Interface, abstract 키워드를 사용
- 클래스의 기능을 사용할 때에는 기능을 하는 메서드의 역할만 알면 되고, 내부 구현에 대해선 알 필요가 없음
- 추상화는 실제로 특별한 문법 보다는 그냥 함수를 제공해도 사용 가능한 특성
- 추상화를 위한 함수 네이밍에는 일반적이고 추상적인 이름을 사용하는 것이 좋음

## 상속

- is-a 관계를 나타네는 데 사용
- 단일 상속 : 하위 클래스가 단 하나의 상위 클래스만을 상속하는 것
- 다중 상속: 하위 클래스가 여러 상위 클래스를 동시에 상속하는 것
    - Java의 경우, extends 키워드를 사용
    - Java는 단일 상속만 지원
- 상속의 가장 큰 역할은 코드의 재사용
    - 오브젝트에서는 코드 재사용이 1번 역할이 되면 안된다고 했는데…
    - 그렇다고 코드 재사용의 이점이 없는 것은 아니니까!
- 과도하게 사용하면 코드를 살펴볼 때 많은 클래스를 살펴보아야함
- 수정이 필요한 경우 하위 클래스에 큰 영향을 미침

## 다형성

- 코드를 실행할 때 하위 클래스를 상위 클래스 대신 사용하고 메서드를 호출할 수 있는 특성
- 다형성을 사용하기 위해 필요한 문법
    1. 상위 클래스 객체가 하위 클래스 객체 참조 가능
    2. 상속 지원
    3. 상위 클래스의 메서드를 재정의 가능
- 인터페이스를 이용해 구현 가능 → 상속을 통해 메서드 오버라이딩
- duck-typing을 이용해 구현 가능 → 같은 이름의 메서드 구현

## 생각해보기

1. Kotlin 역시 자바와 마찬가지로 다이아몬드 문제 때문에 클래스 다중 상속을 지원하지 않는다. 하지만 인터페이스 다중 상속은 가능하기 때문에 충분히 의미적으로 다중 상속을 구현할 수 있다.
2. Kotlin은 캡슐화를 위해 접근 지정자 문법이 있고, 추상화를 위한 abstract, interface 키워드가 있고, 상속을 위한 : 문법이 있고, 다형성 구현 방식으로 인터페이스를 사용할 수 있다.

# 2.3 객체지향 분석, 객체지향 설계, 객체지향 프로그래밍을 수행하는 방법

- 객체지향으로 어떻게 작업을 시작할 지에 대한 이해를 바탕으로 시작

### 어려움을 겪는 이유

1. 요구 사항이 불분명하다.
2. 경험이 부족하다.

## 요구사항 분석

- 자신만의 방법을 찾는 것이 가장 중요하지만, 대략적인 계획을 세워보는 것이 중요

### 1. 기본 분석

- 기본적으로 필요한 것이 무엇인지 먼저 확인 필요
- 필요한 정보, 정보를 전달받고 요청하는 과정, 이후 결과를 통한 판단 과정

### 2~4. 1~3차 분석

- 이전 단계에서 일어날 수 있는 문제를 파악하고, 그에 대한 해결방법 찾기
- 문제를 파악하고 문제를 해결하는 것이 가장 좋은 반복 최적화 방법

## 객체지향 설계 방법

- 분석이 완료되면 본인이 파악한 요구사항 명세를 얻을 수 있음
- 명세를 통해 클래스 설계를 할 수 있음

### 1. 책임과 기능 분리 / 클래스 종류 확인

- 초보자에게는 클래스 후보를 먼저 나열하고, 구분하는 방법이 따라하기 쉬움
- 이제는 **기능을 나열**하고, **유사한 책임을 묶어** 클래스를 분류하는 방법으로 작업을 해야함
- 명세를 정리했다면 **단일 책임 기능**으로 분해해야 함
- 기능을 분리하여 유사한 기능들에 대한 클래스를 생각할 수 있음

### 2. 클래스, 속성, 메서드 정의

- 보통 속성과 메서드는 하는 역할의 동사와 명사를 이용해 정의
- 모든 명사가 속성으로 정의되는 것이 아닐 수도 있음
    - 매개변수로 전달될 수 도 있다는 점 유의
- 기능 명세에는 없었던 속성, 메서드들을 파악해야 함
- 해당 클래스에 있으면 안되는 속성과 메서드도 파악해야 함

- 위의 설계를 통해 새로운 클래스를 설계하거나, 클래스의 형식을 바꿀 수도 있음

### 3. 클래스 간의 상호작용 정의

1. 일반화 - 단순 상속 관계
2. 실체화 - 인터페이스 - 구현 클래스 관계
3. 집합 - 포함 관계
    - 속성으로 존재하는 경우
    - 수명 주기는 클래스에 종속되지 않을 수도 있음
4. 합성 - 포함 관계
    - 집합과 비슷하지만, 수명 주기가 바깥 클래스에 달려 있음
5. 연관 - 집합과 합성의 속성을 모두 가지는 관계
    - 집합, 합성 코드 모두로 설명 가능
6. 의존 - 연관 관계를 포함한 더 약한 관계
    - 포함하든, 변수로 취급하든 상관없이 관계가 있는 경우

- 앞서 말했던 것처럼 모두 사용할 필요 없음
- 일반화, 실체화, 합성, 의존만 사용할 예정
    - 합성, 집합, 연관을 하나의 관계로 정의

### 4. 클래스 연결 및 실행 엔트리 포인트 제공

- 각 상황에 맞게 설정

## 객체지향 프로그래밍을 하는 방법

- 작업해놓은 것들을 코드로 실체화하는 것
- 클래스 다이어그램을 이용하면 쉽게 구현 가능

# 2.4 객체지향 프로그래밍, 잘처작 프로그래밍, 함수형 프로그래밍의 차이

## 절차적 프로그래밍

- 데이터와 메서드가 관계 없이 순차적으로 실행됨
- 객체지향에 비해 실행 흐름에 대한 제어가 힘듦
- 객체지향에 비해 코드 재사용, 확장, 유지 관리가 어려움
- 객체지향에 비해 사용자 친화적이지 못함

## 함수형 프로그래밍

- 프로그램이 일련의 수학적 함수의 조합으로 표현되는 것
- 유리한 분야가 있는 반면, 대규모 비즈니스 로직에는 부적합
- 함수는 외부 변수에 대한 영행을 전혀 받지 않음
- 최근 객체지향 언어에서도 사용하기 위해 도입하기 시작함

### 1. Stream 클래스

- 계단식 연산을 위한 방법

### 2. 람다 표현식

- 코드 단순화를 위한 것이 목적

### 3. 함수형 인터페이스

- 함수 포인터처럼 사용하는 것

# 2.5 객체지향 프로그래밍처럼 보이지만 실제로는 절차적 프로그래밍

- 객체지향 프로그래밍을 모방하는 방법들에 대한 예시

### 1. getter, setter 메서드 남용

- 속성에 대해 접근하면 캡슐화 특성 위반
- getter가 필요한 경우, 수정되는 것을 미리 방지하는 방법 사용
- setter가 필요한 경우, 캡슐화를 하고 내부에서 상황에 맞게 설정

### 2. 전역 변수, 메서드 남용

- Constants 같은 클래스에 대한 이야기
- 코드 유지 보수에 영향을 미침
    - 파일이 더욱 커지고, 충돌을 일으킬 수 있음
- 컴파일 시간 증가
    - 코드가 많아질수록 더 많은 코드가 종속됨
- 코드 재사용에도 영향 미침
    - 특정 클래스를 다른 프로젝트에서 쓰려고 할때, Constants를 사용하고 있다면 쓸데없는 상수들이 모듈에 포함됨
- 각 상황에 맞게 작은 Utils 파일들로 나누는 것도 필요

### 3. 데이터와 메서드 분리로 클래스 정의하기

- 데이터 클래스와 메서드 클래스를 분리하는 것이 절차적인 프로그래밍 스타일

## 생각해보기

1. 객체지향 처럼 보이지만 절차적 프로그래밍 방식인 코드… 사실 이미 3번에서 충격 받음… 저것도 절차지향이구나…

# 2.6 빈약한 도메인 모델에 기반한 전통적인 개발방식은 OOP를 위반하는가?

- 흔히 안티 패턴이라고 부름

## 빈약한 도메인 모델에 기반한 전통 개발 방식

- 보통 백엔드에서 MVC 아키텍처를 사용함
- 데이터만 포함하고 비즈니스 로직이 없는 순수 데이터 클래스가 빈약한 도메인 모델에 해당함

## 풍성한 도메인 모델에 기반한 DDD 개발 방식

- 데이터와 비즈니스 논리가 하나의 클래스에 포함되는 것
- DDD : 비즈니스 시스템, 모듈을 분할하고, 비즈니스 도메인 모델과 상호작용을 정의하는 방법
- MVC를 예로 들면
    - 컨트롤러 계층 : 인터페이스 노출
    - 저장소 계층 : 데이터 액세스 담당
    - 서비스 계층 : 비즈니스 논리 담당
- 차이점은 서비스 계층 내부에 있음
    - BO 클래스와 Service 클래스로 구성되는 게 기존 방법
    - BO 클래스 대신 Domain 클래스를 사용해 데이터와 비즈니스 논리를 모두 포함하는 역할을 함
    - 상대적으로 Service 클래스가 가벼워짐
- Service 클래스는 왜 있어야 하는가?
    - 저장소 계층과의 통신을 위해 - 도메인 모델을 분리하기 위해
    - 여러 도메인 모델의 비즈니스 논리를 결합
    - 기능과 무관한 타 시스템과의 상호작용도 담당

# 2.7 추상 클래스와 인터페이스

### 1. 추상 클래스

- 인스턴스화 할 수 없으며 상속만 가능
- 속성과 메서드를 포함할 수 있음
    - 코드 구현이 없는 추상 메서드 사용 가능
- 상속 받을 때 모든 추상 메서드를 실제로 구현해야 함

### 2. 인터페이스

- 속성을 포함할 수 없음
- 메서드 선언은 가능, 코드 구현 포함 안됨
- 구현할 때 모든 메서드를 구현해야 함
- is-a 대신 has-a 관계가 존재 (계약)

- 버전 업그레이드 이후에 인터페이스에 정적 멤버나 메서드 코드 구현도 추가되긴 했음

- 둘의 가장 큰 차이는?
    - 추상 클래스는 코드 재사용 (이래도 되는거 맞나)
    - 인터페이스는 디커플링

# 2.8 인터페이스 기반 프로그래밍: 모든 클래스에 대해 인터페이스를 정의해야할까?

- 인터페이스의 본질 : 프로토콜 또는 규약의 집합
    - 사용자에게 제공되는 기능의 목록
- 구현을 분리하여 불안정한 구현을 캡슐화로 감추고, 안정적인 인터페이스만 노출시키는 것
- 구현이 아닌 추상화에 기반한 프로그래밍

- 인터페이스 사용에도 정도가 필요 - 남용하면 안됨
- 특정 기능에 대한 구현 방법이 하나 뿐이라면 인터페이스는 필요 없음
- 함수의 변경이 있어도 변경에 문제가 없다면 직접 수정해도 됨

# 2.9 상속보다 합성

- 상속의 단계가 깊고 복잡해지는 것에 대한 논쟁이 생김
- 수많은 예외를 위해 코딩 작업량을 늘리고, 노출되면 안되는 인터페이스가 노출되며 잘못 사용될 수 있음
- 각 상황에 따른 다른 상속구조를 또 낳게 됨
- 이러한 상속 문제는 합성, 인터페이스, 위임을 통해 해결 가능

⇒ 상황에 맞게 상속이 필요하면 사용할 줄 알아야 함