# 2 객체지향 프로그래밍 패러다임

- 캡슐화, 추상화, 상속, 다형성 4가지 특성을 갖춰야만 OOP냐?
➡ 놉
- javascript는 캡슐화와 상속을 지원하지 않는다. 그럼 OOP 프로그래밍 언어가 아닌가?
➡ 놉

그.. 꼭 그렇게 정의를 해야만 해?
객체지향이라는 개념은 등장 이래 끊임없이 진화해왔기 때문에 정의를 내리기 모호하다 (그럴 필요도 없다)

### 객체지향 분석과 설계
- 요구사항을 분석하고 설계
  - 프로그램이 어떤 클래스로 분해 구성되는지
  - 각 클래스가 어떤 속성과 메서드를 가지는지
  - 클래스끼리 상호 작용하는 인터페이스를 포함한 클래스 설계

## OOP 특성들이 등장한 이유
- 캡슐화, 추상화, 상속, 다형성이 존재하는 의미
- 이 특성들을 이용해야만 해결할 수 있는 문제는 무엇인가?

### 캡슐화
- 접근 가능한 인터페이스를 제한하여 외부에서는 클래스가 제공하는 메서드를 통해서만 접근 허가 

😝 엥~ 접근 제한 다 풀어버려서 유연하게 접근하고 수정해버리기~~~

➡ 과도한 유연성 = 제어할 수 없음
- 속성이 이상한 방식으로 수정될 수 있음
- 수정 논리가 코드 구석구석 흩어져버려 가독성과 유지보수성 다운

✅ 제한된 메서드를 제공했을 때의 이점?
- 필요한 작업만 노출되어 있어 잘못 사용할 가능성 줄어듬
- 기능을 단순화하고 정리하는 의미

### 추상화
- 메서드의 내부 구현을 숨기는 것 (= 퍼블릭 인터페이스만 노출, 구현은 알빠노)
- OOP뿐만 아니라 아키텍쳐 설계에도 쓰이는 개념

✅ 추상화의 효과?
- 복잡한 시스템에서 불필요한 정보를 걸러냄
- 광범위한 설계 기반

### 상속
- is-a 관계 
- 코드의 재사용 <- 오브젝트 저자님과 원만한 합의 바랍니다.

😝 상속해서 재재재재사용 개꿀~~

➡ 상속 계층 구조가 깊어짐
- 특정 클래스의 기능을 이해하기 위해 상위 클래스, 상상위 클래스의 코드도 봐야함
- 하위 클래스와 상위 클래스가 밀접하게 결합되어 있으면 상위의 수정이 하위에 영향
- 적게 사용해야 하는 안티 패턴으로 간주되기도 함

### 다형성
- 코드 실행 과정에서 하위 클래스를 상위 클래스 대신 사용할 수 있음
- 코드의 재사용성 향상
- 전략 패턴, 인터페이스 기반 프로그래밍, 의존 역전 원칙, 리스코프 치완 원칙, 다형성을 이용한 if-else 구문 제거 등의 기초

## 객체지향 분석, 설계, 프로그래밍을 수행하는 방법
- 요구사항 분석은 어떻게 해야하는가?
- 책임 분담?
- 어떤 클래스를 정의하고, 어떤 속성과 메서드를 배치하는가?
- 클래스들은 어떻게 상호작용하는가?

1. 책임과 기능을 나누고 어떤 클래스가 있는지 확인
   - 요구사항을 단일 책임 기능으로 분해
   - 기능 목록 중 연관된 녀석들을 묶어 클래스로
2. 클래스 정의, 속성과 메서드 정의
3. 클래스 간 상호작용 정의
   - 일반화 ➡ 상속
   - 실체화 ➡ 인터페이스와 구현
   - 집합, 합성, 연관, 의존...
4. 클래스 연결 후 실행 엔트리 포인트 제공

반복을 통해 지속적으로 최적화해야 함을 명심하라. 

## 절차 vs 객체 vs 함수
- 절차적 프로그래밍
  - 프로그래밍 패러다임
  - 코드 구성 기본단위: 메서드, 기능, 연산 (절차)
  - 메서드와 데이터가 분리되어 있음
  - 순서대로 실행되는 메서드를 나열하여 데이터 조작

🤔 절차적 프로그래밍에서 객체지향으로 넘어온 사연?
- OOP가 대규모의 복잡한 개발에 적합
  - 요구사항이 간단하고 일직선 형태의 작업 흐름을 가진다면 절차가 유리
  - 하지만 현실세계의 문제들은 더 복잡한 경우가 많음
- OOP 스타일의 코드는 재사용, 확장, 유지 관리가 쉬움
  - 캡슐화 ➡ 클래스 기반
  - 추상화 ➡ 둘 다 지원하지만 인터페이스 기반은 OOP에서만
  - 다형성 ➡ 수정에 폐쇄적이고 확장에 개방적
- OOP가 사용자 친화적이다
  - 이진 > 어셈블리 > 절차 > 객체로 진화해온 역사를 보면 그럴만하다 
  - OOP는 인간의 사고방식, 절차까지는 컴퓨터의 사고방식
  - 비즈니스를 모델링할 때는 실제 세계 기반이다

- 함수형 프로그래밍
    - 요오즘 MZ 기술 같아보이지만 사실 50년도 넘은 근-본
    - 여기서 말하는 함수는 우리가 쓰는 함수가 아니라 y = f(x)의 함수
    - 표현식의 조합으로 프로그램을 표현
    - stateless function: 상태를 가지지 않음
      - 함수의 실행 결과는 입력 매개변수에만 관련되어 있음
      - 외부 변수의 영향을 받지 않음
      - 동일한 입력이면 동일한 결과

>> (3 - 1) * 2 + 5

```kotlin
add(multiply(subtract(3, 1), 2), 5)
```

```kotlin
subtract(3, 1).multiply(2).add(5)
```

## 클래스만 나눈다고 객체지향이 아니다
- getter, setter 남용
  - 노출하지 않아야 하는 setter 노출 ➡ 캡슐화 위반
  - 컬렉션을 반환하는 getter ➡ 외부에서 값을 직접 수정할 수 있음
- 전역 변수와 메서드 남용
  - 싱글톤, 정적 멤버 변수, 상수, 전역 메서드
  - Constants에 상수를 다 몰아넣기 ➡ 너무 비대해졌을 때 컴파일과 유지보수 시간이 늘어남 (Constants가 수정될때마다 종속된 다른 클래스가 매번 다시 컴파일)
  1. 기능에 따라 Constants 클래스 분리
  2. 클래스 자신이 쓸 상수를 클래스 안에 선언
- 데이터와 메서드 분리로 클래스 정의하기
  - MVC 기반부터 계층을 나누는 방법
  - 빈약한 도메일 모델 기반 개발 방식
  - 전형적인 절차적 프로그래밍 스타일이다

## 빈약한 도메인 모델에 기반한 전통적인 개발방식은 OOP를 위반하는가?
- MVC 아키텍쳐
  - 프레젠테이션, 논리, 데이터 3가지 계층
  - 데이터만 포함하고 비즈니스 논리는 포함하지 않음 ➡ 도메인 모델
- 풍성한 도메인 모델? Rich Domain Model
  - 데이터와 비즈니스 로직이 하나의 클래스에
- 빈약한 도메인 모델 개발 방식이 널리 사용되는 이유
  - 대부분 SQL 기반의 CURD 작업 ➡ 비즈니스 로직이 간단➡ 빈약한 도메일이 적합
  - 풍성한 도메인 모델은 설계가 까다롭다

## 추상클래스와 인터페이스

### 추상클래스
- is-a
- 인스턴스화 불가능, 상속만 가능
- 속성과 메서드 포함
- 하위 클래스는 추상 클래스를 상속할 때 모든 추상메서드를 구현해야 함

### 인터페이스
- contract
- 속성을 포함하지 않음
- 메서드를 선언할 수 있으나, 구현 코드를 포함 불가
  - Kotlin은 포함할 수 있지롱
- 인터페이스를 구현할 때 인터페이스에 선언된 모든 메서드를 구현해야 함
  
### 문법적인 차이 말고!@!

추상클래스
- 상속을 통해 코드 재사용 가능
  - 근데 그럴거면 그냥 상속해도 되는거 아님?
- 추상 메서드 구현을 강제화
  - 하위 클래스를 정의할 때 까먹지 않음
- 인스턴스 생성을 막음으로 구현이 없는 상위클래스의 메서드 접근을 차단
- 상향식 설계
  - 하위 클래스의 코드를 반복하다가 상위 클래스를 추상화

인터페이스
- 디커플링
- 인터페이스만 알고, 구현은 모른다. 
  - 규칙과 구현을 분리하여 결합도 다운! 확장성 업!
- 하향식 설계
  - 인터페이스를 먼저 설계한 다음 구현을 고려
- 인터페이스 정의
  - 프로토콜 또는 규약의 집합, 사용자에게 제공되는 기능의 목록
- 코드 품질이 향상되는 이유
    - 구현과 인터페이스를 분리하여 변할 수 있는 구현을 캡슐화하고 안정적인 인터페이스만 노출
    - 세부 사항에 의존하지 않아도 됨
    - 업스트림 시스템 코드 변경 필요 없음

## 인터페이스가 좋은 것이구나, 그럼 모든 클래스에 대해 인터페이스 정의하면 더 좋은거 아닌가요??

😅 정도를 지키세요...

인터페이스 남용하면 벌어지는 일
- 클래스별로 인터페이스를 정의
- 흩어진 인터페이스는 부담
- 특정 시나리오에 대한 방법이 하나뿐이면 추상화할 필요가 없다

## 상속보다 합성
- 상속이 비추되는 이유
  - 상속 단계가 너무 깊고 복잡해지면 코드 유지보수 불편
  - 예외가 발생하면 매번 재정의하고 예외를 발생시켜야 함
- 합성이 상속에 비해 갖는 장점
  - 합성, 인터페이스, 위임
  - 코드 재사용은 합성과 위임으로 달성, 다형성은 인터페이스로 달성
- 그렇다고 상속이 사회악이냐? 그건 또 아님
  - 클래스 간의 상속 구조가 쉽게 변경되지 않고, 2단계 이하로 얕다면 상속 사용할만 함

