# 2 객체지향 프로그래밍 패러다임

- 캡슐화, 추상화, 상속, 다형성 4가지 특성을 갖춰야만 OOP냐?
➡ 놉
- javascript는 캡슐화와 상속을 지원하지 않는다. 그럼 OOP 프로그래밍 언어가 아닌가?
➡ 놉

그.. 꼭 그렇게 정의를 해야만 해?
객체지향이라는 개념은 등장 이래 끊임없이 진화해왔기 때문에 정의를 내리기 모호하다 (그럴 필요도 없다)

### 객체지향 분석과 설계
- 요구사항을 분석하고 설계
  - 프로그램이 어떤 클래스로 분해 구성되는지
  - 각 클래스가 어떤 속성과 메서드를 가지는지
  - 클래스끼리 상호 작용하는 인터페이스를 포함한 클래스 설계

## OOP 특성들이 등장한 이유
- 캡슐화, 추상화, 상속, 다형성이 존재하는 의미
- 이 특성들을 이용해야만 해결할 수 있는 문제는 무엇인가?

### 캡슐화
- 접근 가능한 인터페이스를 제한하여 외부에서는 클래스가 제공하는 메서드를 통해서만 접근 허가 

😝 엥~ 접근 제한 다 풀어버려서 유연하게 접근하고 수정해버리기~~~

➡ 과도한 유연성 = 제어할 수 없음
- 속성이 이상한 방식으로 수정될 수 있음
- 수정 논리가 코드 구석구석 흩어져버려 가독성과 유지보수성 다운

✅ 제한된 메서드를 제공했을 때의 이점?
- 필요한 작업만 노출되어 있어 잘못 사용할 가능성 줄어듬
- 기능을 단순화하고 정리하는 의미

### 추상화
- 메서드의 내부 구현을 숨기는 것 (= 퍼블릭 인터페이스만 노출, 구현은 알빠노)
- OOP뿐만 아니라 아키텍쳐 설계에도 쓰이는 개념

✅ 추상화의 효과?
- 복잡한 시스템에서 불필요한 정보를 걸러냄
- 광범위한 설계 기반

### 상속
- is-a 관계 
- 코드의 재사용 <- 오브젝트 저자님과 원만한 합의 바랍니다.

😝 상속해서 재재재재사용 개꿀~~

➡ 상속 계층 구조가 깊어짐
- 특정 클래스의 기능을 이해하기 위해 상위 클래스, 상상위 클래스의 코드도 봐야함
- 하위 클래스와 상위 클래스가 밀접하게 결합되어 있으면 상위의 수정이 하위에 영향
- 적게 사용해야 하는 안티 패턴으로 간주되기도 함

### 다형성
- 코드 실행 과정에서 하위 클래스를 상위 클래스 대신 사용할 수 있음
- 코드의 재사용성 향상
- 전략 패턴, 인터페이스 기반 프로그래밍, 의존 역전 원칙, 리스코프 치완 원칙, 다형성을 이용한 if-else 구문 제거 등의 기초

## 객체지향 분석, 설계, 프로그래밍을 수행하는 방법
- 요구사항 분석은 어떻게 해야하는가?
- 책임 분담?
- 어떤 클래스를 정의하고, 어떤 속성과 메서드를 배치하는가?
- 클래스들은 어떻게 상호작용하는가?

1. 책임과 기능을 나누고 어떤 클래스가 있는지 확인
   - 요구사항을 단일 책임 기능으로 분해
   - 기능 목록 중 연관된 녀석들을 묶어 클래스로
2. 클래스 정의, 속성과 메서드 정의
3. 클래스 간 상호작용 정의
   - 일반화 ➡ 상속
   - 실체화 ➡ 인터페이스와 구현
   - 집합, 합성, 연관, 의존...
4. 클래스 연결 후 실행 엔트리 포인트 제공

반복을 통해 지속적으로 최적화해야 함을 명심하라. 

## 절차 vs 객체 vs 함수
- 절차적 프로그래밍
  - 프로그래밍 패러다임
  - 코드 구성 기본단위: 메서드, 기능, 연산 (절차)
  - 메서드와 데이터가 분리되어 있음
  - 순서대로 실행되는 메서드를 나열하여 데이터 조작

🤔 절차적 프로그래밍에서 객체지향으로 넘어온 사연?
- OOP가 대규모의 복잡한 개발에 적합
  - 요구사항이 간단하고 일직선 형태의 작업 흐름을 가진다면 절차가 유리
  - 하지만 현실세계의 문제들은 더 복잡한 경우가 많음
- OOP 스타일의 코드는 재사용, 확장, 유지 관리가 쉬움
  - 캡슐화 ➡ 클래스 기반
  - 추상화 ➡ 둘 다 지원하지만 인터페이스 기반은 OOP에서만
  - 다형성 ➡ 수정에 폐쇄적이고 확장에 개방적
- OOP가 사용자 친화적이다
  - 이진 > 어셈블리 > 절차 > 객체로 진화해온 역사를 보면 그럴만하다 
  - OOP는 인간의 사고방식, 절차까지는 컴퓨터의 사고방식
  - 비즈니스를 모델링할 때는 실제 세계 기반이다

- 함수형 프로그래밍
    - 요오즘 MZ 기술 같아보이지만 사실 50년도 넘은 근-본
    - 여기서 말하는 함수는 우리가 쓰는 함수가 아니라 y = f(x)의 함수
    - 표현식의 조합으로 프로그램을 표현
    - stateless function: 상태를 가지지 않음
      - 함수의 실행 결과는 입력 매개변수에만 관련되어 있음
      - 외부 변수의 영향을 받지 않음
      - 동일한 입력이면 동일한 결과

>> (3 - 1) * 2 + 5

```kotlin
add(multiply(subtract(3, 1), 2), 5)
```

```kotlin
subtract(3, 1).multiply(2).add(5)
```

- 계단식 호출.